<h2>Include Header</h2>
<pre><code>#include &lt;vector&gt;</code></pre>

<h2>Declaration</h2>
<pre><code>std::vector&lt;Type&gt; vec_name;</code></pre>

<h2>Insertion</h2>
<pre><code>
vec_name.push_back(value);                      // Add to end
vec_name.insert(vec_name.begin() + index, value);  // Insert at position
</code></pre>

<h2>Access Element</h2>
<pre><code>
Type val = vec_name[index];         // Direct access
Type val = vec_name.at(index);      // Bounds-checked access
</code></pre>

<h2>Check if Empty</h2>
<pre><code>
if (vec_name.empty()) {
  // Vector is empty
}
</code></pre>

<h2>Erase Element</h2>
<pre><code>
vec_name.erase(vec_name.begin() + index);  // Remove at index
vec_name.clear();                          // Remove all elements
</code></pre>

<h2>Iterate Through Elements</h2>
<pre><code>
for (const auto&amp; val : vec_name) {
  std::cout &lt;&lt; val &lt;&lt; std::endl;
}
</code></pre>

<p>In reverse order:</p>
<pre><code>
for (auto it = vec.rbegin(); it != vec.rend(); ++it) {
  std::cout &lt;&lt; *it &lt;&lt; " ";
}
</code></pre>

<h2>Reverse the order of a Vector</h2>
<pre><code>
std::reverse(vec.begin(), vec.end());
</code></pre>

<h2>Size and Capacity</h2>
<pre><code>
vec_name.size();            // Number of elements
vec_name.capacity();        // Allocated storage capacity
vec_name.resize(new_size);  // Resize vector
</code></pre>

<h2>Other Useful Functions</h2>
<pre><code>
vec_name.front();       // First element
vec_name.back();        // Last element
vec_name.pop_back();    // Remove last element
</code></pre>

<h2>Check if Element Exists</h2>
<pre><code>#include &lt;algorithm&gt;

if (std::find(vec_name.begin(), vec_name.end(), value) != vec_name.end()) {
  // Element found
} else {
  // Element not found
}
</code></pre>

<h2>Ways to Construct a Vector</h2>
<pre><code>
// Empty vector
std::vector&lt;int&gt; v1;

// Vector with 5 default-initialized ints (0)
std::vector&lt;int&gt; v2(5);

// Vector with 5 elements, each initialized to 42
std::vector&lt;int&gt; v3(5, 42);

// Copy constructor
std::vector&lt;int&gt; v4 = v3;

// Move constructor
std::vector&lt;int&gt; v5 = std::move(v3);

// Construct from initializer list
std::vector&lt;int&gt; v6 = {1, 2, 3, 4, 5};

// Construct from array
int arr[] = {10, 20, 30};
std::vector&lt;int&gt; v7(std::begin(arr), std::end(arr));

// Construct from iterators
std::vector&lt;int&gt; source = {5, 6, 7};
std::vector&lt;int&gt; v8(source.begin(), source.end());
</code></pre>

<h2>Filter a Vector</h2>
<p>To create a filtered vector based on some property of the elements, use <code>std::copy_if</code> or C++20 <code>std::ranges::copy_if</code>. Here are two examples:</p>

<p><strong>C++11 and later:</strong></p>
<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;

std::vector&lt;int&gt; original = {1, 2, 3, 4, 5, 6};
std::vector&lt;int&gt; filtered;

std::copy_if(original.begin(), original.end(), std::back_inserter(filtered),
             [](int x) { return x % 2 == 0; });  // Keep even numbers
</code></pre>

<p><strong>C++20 (with ranges):</strong></p>
<pre><code>#include &lt;vector&gt;
#include &lt;ranges&gt;

std::vector&lt;int&gt; original = {1, 2, 3, 4, 5, 6};
std::vector&lt;int&gt; filtered;

std::ranges::copy_if(original, std::back_inserter(filtered),
                    [](int x) { return x % 2 == 0; });  // Keep even numbers
</code></pre>
<h2>Join Two Vectors</h2>
<p>To join or concatenate two vectors, you can use <code>std::insert</code> to append the contents of one vector to the end of another:</p>

<pre><code>#include &lt;vector&gt;

std::vector&lt;int&gt; v1 = {1, 2, 3};
std::vector&lt;int&gt; v2 = {4, 5, 6};

// Append v2 to v1
v1.insert(v1.end(), v2.begin(), v2.end());
</code></pre>

<p>After this, <code>v1</code> contains <code>{1, 2, 3, 4, 5, 6}</code>.</p>

<p>If you want to create a new vector that is the result of joining two vectors:</p>

<pre><code>#include &lt;vector&gt;

std::vector&lt;int&gt; v1 = {1, 2, 3};
std::vector&lt;int&gt; v2 = {4, 5, 6};

std::vector&lt;int&gt; joined;
joined.reserve(v1.size() + v2.size());  // Optional, to improve performance

joined.insert(joined.end(), v1.begin(), v1.end());
joined.insert(joined.end(), v2.begin(), v2.end());
</code></pre>


<h2>Vector Constructors and Operations: When They Are Called</h2>
<p>In C++, different vector operations can trigger different constructors (copy, move, or default), for the objects that it holds. Understanding this is important to avoid unnecessary copies, improve performance, and correctly manage resources.</p>
<h3>1. Push Back</h3>
<pre><code> std::vector<MyClass> vec; MyClass obj;

// Copy version
vec.push_back(obj); // Calls MyClass copy constructor

// Move version (C++11+)
vec.push_back(std::move(obj)); // Calls MyClass move constructor
</code></pre>
<p><strong>Note:</strong> Using <code>std::move</code> avoids copying large objects unnecessarily.</p>
<h3>2. Insert</h3>
<pre><code> 
  vec.insert(vec.begin() + 2, obj); // Copy constructor called 
  vec.insert(vec.begin() + 2, std::move(obj)); // Move constructor called </code></pre>
<p>If inserting a range of elements, move constructors are used if available:</p>
<pre><code> std::vector<MyClass> other = {...}; vec.insert(vec.end(), std::make_move_iterator(other.begin()), std::make_move_iterator(other.end())); // Moves elements from other </code></pre>
<h3>3. Resize</h3>
<pre><code> 
  vec.resize(10); // Default constructor called for new elements 
  vec.resize(10, obj); // Copy constructor called for new elements 
</code></pre>
<h3>4. Erase</h3>
<pre><code> vec.erase(vec.begin() + 3); </code></pre>
<p>When you erase an element from a vector, all elements after the erased element are **shifted left**. This triggers either:</p>
<ul>
  <li>Move constructor (if available and noexcept)</li>
  <li>Copy constructor (if move is not available)</li>
</ul>
<p>For example, if <code>MyClass</code> has a move constructor, <code>erase</code> will use moves instead of copies to shift elements.</p>
<h3>5. Copying a Vector</h3>
<pre><code> std::vector<MyClass> vec2 = vec; // Copy constructor of MyClass called for each element </code></pre>
<h3>6. Moving a Vector</h3>
<pre><code> std::vector<MyClass> vec2 = std::move(vec); // Move constructor of vector is called // Individual MyClass move constructors are generally NOT called // because vector just transfers ownership of its internal buffer </code></pre>
<h3>7. Emplace Operations</h3>
<pre><code> vec.emplace_back(args...); // Constructs MyClass in-place (no copy or move) vec.emplace(vec.begin(), args...); // Constructs in-place at specific position </code></pre>
<p><strong>Note:</strong> <code>emplace</code> avoids unnecessary construction and copying/moving by constructing elements directly inside the vector.</p>
<h3>Summary Table</h3>
<table>
    <tr>
        <th>Operation</th>
        <th>Constructor Called</th>
    </tr>
    <tr>
        <td>push_back(obj)</td>
        <td>Copy constructor</td>
    </tr>
    <tr>
        <td>push_back(std::move(obj))</td>
        <td>Move constructor</td>
    </tr>
    <tr>
        <td>insert(position, obj)</td>
        <td>Copy constructor</td>
    </tr>
    <tr>
        <td>insert(position, std::move(obj))</td>
        <td>Move constructor</td>
    </tr>
    <tr>
        <td>resize(new_size)</td>
        <td>Default constructor for new elements</td>
    </tr>
    <tr>
        <td>resize(new_size, obj)</td>
        <td>Copy constructor for new elements</td>
    </tr>
    <tr>
        <td>erase(position)</td>
        <td>Move constructor (if available) for shifting elements</td>
    </tr>
    <tr>
        <td>vector copy</td>
        <td>Copy constructor for each element</td>
    </tr>
    <tr>
        <td>vector move</td>
        <td>Move constructor of vector; elements usually not moved</td>
    </tr>
    <tr>
        <td>emplace / emplace_back</td>
        <td>In-place constructor (no copy or move)</td>
    </tr>
</table>
<p>Understanding these rules helps optimize performance, especially for classes with expensive copy operations like `IVPColor`.</p>

