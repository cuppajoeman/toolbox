<p>
    When working <a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commits v1.0.0</a>, there are a few situations that might need thinking about.
</p>

<h2>multiple scopes</h2>
<p>
    As required by the standard, there is only one scope, but sometimes this doesn't make sense. To see why suppose we're working on a game engine, and we want to add in a gui element showing how much ping we have, we start working on the feature, but it sspans into the networking code and also the gui code, in our codebase we currently have the scopes networking and gui defined, and so when completing this feature we see that it involves two scopes.
</p>
<p>
Potentially in the future there will be a way to specify this with (networking, gui), but since this is not supported by the v1.0.0 conventional commits standard, then what we can do instead is make a new scope which is networking-gui in such a case, the only difference here is just a change from ", " to "-", and that the ordering matters.
</p>

<h2>submodules</h2>
<p>
    Some people use submodules just to include dependencies that they don't work on, and simply update the version, in such a case using <code>chore</code> as the type can make sense, unless these changes actually have a substantial effect on your codebase and in that case you either commit how the change effect the entire codebase, for example suppose a submodule had a performance upgrade, then perhaps this change improves UI speed by 25% percent on your computer, then in that case you could commit with that info in your repository such as <code>perf(ui): ...</code>, this can make sense because in a way by using someone ele's code as a submodule in your code, it really is a piece of your code, which was just updated by someone that was not you, and so it's not just a chore.
</p>

<p>
    If you simply use submodules as organization tools for your own code which you can <a href="/tool_howtos/git/submodules.html">read about here</a>, then follow that page as a guide, and simply use conventional commits applied to the method of committing there.
</p>

<hr>

<h1>Quick examples</h1>
<ul>
<li><code>feat: new feature</code></li>
    <li><code>fix(scope): bug in scope</code></li>
    <li><code>feat!: breaking change</code> / <code>feat(scope)!: rework API</code></li>
    <li><code>chore(deps): update dependencies</code></li>
</ul>

<h1>Commit types</h1>
<ul>
    <li><code>build</code>: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)</li>
    <li><code>ci</code>: Changes to CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)</li>
    <li><b><code>chore</code></b>: Changes which don't change source code or tests, e.g. changes to the build process, auxiliary tools, libraries</li>
    <li><code>docs</code>: Documentation only changes</li>
    <li><b><code>feat</code></b>: A new feature</li>
    <li><b><code>fix</code></b>: A bug fix</li>
    <li><code>perf</code>: A code change that improves performance</li>
    <li><code>refactor</code>: A code change that neither fixes a bug nor adds a feature</li>
    <li><code>revert</code>: Revert something</li>
    <li><code>style</code>: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)</li>
    <li><code>test</code>: Adding missing tests or correcting existing tests</li>
</ul>

<h1>Reminders</h1>
<ul>
    <li>Put a newline before extended commit body</li>
    <li>More details at <b><a href="https://www.conventionalcommits.org/">conventionalcommits.org</a></b></li>
</ul>
